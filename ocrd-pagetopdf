#!/bin/bash
set -eu
set -o pipefail
# showing cmd execution on std (deactivated for productive use)
# set -x

which ocrd >/dev/null 2>/dev/null || { echo "ocrd not in \$PATH. Panicking"; exit 1; }

SHAREDIR="$(cd "$(dirname "$0")" >/dev/null && pwd)"
SCRIPT_NAME="${0##*/}"

MIMETYPE_PAGE=$(ocrd bashlib constants MIMETYPE_PAGE)

# FIXME: add a bashlib wrapper for logging to use here
function log {
    echo >&2 "$(date +%T.%3N) $LEVEL $SCRIPT_NAME - $*"
}
function critical { LEVEL=CRITICAL log "$*"; }
function error { LEVEL=ERROR log "$*"; }
function warning { LEVEL=WARNING log "$*"; }
function info { LEVEL=INFO log "$*"; }
function debug { LEVEL=DEBUG log "$*"; }

main () {
    # Load ocrd bashlib functions
    # shellcheck source=../core/ocrd/bashlib/lib.bash
    source $(ocrd bashlib filename)

    # Describe calling script to lib.bash
    ocrd__wrap "$SHAREDIR/ocrd-tool.json" "$SCRIPT_NAME" "$@"

    cd "${ocrd__argv[working_dir]}"
    IFS=',' read -ra in_grps <<< "${ocrd__argv[input_file_grp]}"
    echo $in_grps
    if [ ${#in_grps[@]} -ne "2" ]; then
        echo "If you want to generate a PDF, please provide two input-file-grps: -I PAGE-XML,IMG"
        exit 1
     fi 
    in_file_grp="${in_grps[0]}"
	img_file_grp="${in_grps[1]}"
    out_file_grp=${ocrd__argv[output_file_grp]}
    mkdir -p $out_file_grp

    # Parameters
    local negative2zero output_extension
    options=()
    if [ -z ${params['textequiv_level']:=} ]; then
        warning "If you want to add a text layer, please set parameter 'textequiv_level' accordingly!"
    else
        # first letter is sufficient (case does not matter)
        options+=(-text-source ${params['textequiv_level']:0:1})
    fi
    options+=(${params['font']:+-font} ${params['font']:-})
    if [ -n ${params['outlines']:=} ]; then
        # first letter is sufficient (case does not matter)
        options+=(-outlines ${params['outlines']:0:1})
    fi
    case ${params['negative2zero']} in
        [tT]rue|1)
            negative2zero=1
            ;;
        *)
            negative2zero=0
    esac
    options+=(${params['script-args']})
    output_extension=${params['ext']}

    # Download the files and do the conversion
    local IFS=$'\n'
    files=($(ocrd workspace find \
        ${page_id:+-g} ${page_id:-} \
        -G $in_file_grp \
        -k local_filename \
        -k ID \
        -k pageId \
        --download))
    local IFS=$' \t\n'
    local n=0 zeros=0000
    for csv in "${files[@]}"; do
        let n+=1
        # Parse comma separated fields
        local IFS=$'\t'
        local fields=($csv)
        local IFS=$' \t\n'

        local in_file="${fields[0]}"
        local in_id="${fields[1]}"
        local pageid="${fields[2]:-}"
		
        if ! test -f "$in_file"; then
           error "input file \"$in_file\" ID=${in_id} (pageId=${pageid}) is not on disk"
           continue
        fi
        
        # Rework coords in PAGE
        if ((negative2zero)); then
            local tmpfile
            tmpfile=$(mktemp --tmpdir ocrd-pagetopdf.XXXXXX)
            python3 "$SHAREDIR/ptp/negative2zero.py" "$in_file" $tmpfile
            in_file=$tmpfile
        fi
	options+=(-xml "$in_file")

        img_file=$(ocrd workspace find \
                        -g $pageid -G $img_file_grp \
                        -k local_filename --download)

        if ! test -f "$img_file"; then
           error "no image file in  \"$img_file_grp\""
           continue
        fi
        options+=(-image "$img_file")

        # Output filename
        local out_id="${in_id//$in_file_grp/$out_file_grp}"
        if [ "x$out_id" = "x$in_id" ]; then
            out_id=${out_file_grp}_${zeros:0:$((4-${#n}))}$n
        fi
        options+=(-pdf "$out_file_grp/${out_id}$output_extension")

        java -jar "$SHAREDIR/ptp/PageToPdf.jar" "${options[@]}"

        if ((negative2zero)); then
            rm $tmpfile
        fi

    done
}


main "$@"
